#!/usr/bin/env python3

from exec_trace import ExecTrace
output_dir = ""
game_level = None
cinematic_counter = 0
video2_counter = 0
cinematic_entries = {}
video2_entries = {}
romset_dir = None
str_data = None

VIDEO2=0 # shared polygon resource
CINEMATIC=1 # level-specific bank of polygonal data


def get_text_string(str_id):
    global str_data
    try:
        if not str_data:
            str_data = open(f"{romset_dir}/str_data.rom", "rb").read()

        str_index = open(f"{romset_dir}/str_index.rom", "rb")
        str_index.seek((str_id-1)*2)
        str_index.read(1)
        index = ord(str_index.read(1))
        index = index << 8 | ord(str_index.read(1))
        str_index.close()

        the_string = ""
        while str_data[index] != 0x00:
            c = chr(str_data[index])
            if c == '\n':
                c = "\\n"
            the_string += c
            index += 1
    except:
        the_string = f"string_{str_id}"
    return the_string


LABELED_CINEMATIC_ENTRIES = {
    0x9ADC: "SLUG_0",
    0x9B04: "SLUG_1",
    0x9B30: "SLUG_2",
    0x9B60: "SLUG_3",
    0x9B90: "SLUG_4",
    0x9BC0: "SLUG_5",
    0x9BF0: "SLUG_6",
    0x9C20: "SLUG_7",
    0x9C50: "SLUG_8",
    0x9C80: "SLUG_9",
    0x9CB0: "SLUG_10",
    0x9CE0: "SLUG_11",
    0x9D10: "SLUG_12",
    0x9D3C: "SLUG_13"
}


def register_cinematic_entry(x, y, zoom, address):
    global cinematic_counter
    if address in cinematic_entries.keys():
        return cinematic_entries[address]["label"]

    if address in LABELED_CINEMATIC_ENTRIES:
        label = "LEVEL_%d_CINEMATIC_%s" % (game_level, LABELED_CINEMATIC_ENTRIES[address])
    else:
        label = "LEVEL_%d_CINEMATIC_%03d" % (game_level, cinematic_counter)
    cinematic_counter += 1
    cinematic_entries[address] = {
        'x': x,
        'y': y,
        'zoom': zoom,
        'label': label
    }
    return label


def register_video2_entry(x, y, zoom, address):
    global video2_counter
    if address in video2_entries.keys():
        return video2_entries[address]["label"]

    label = "COMMON_VIDEO_%03d" % (video2_counter)
    video2_counter += 1
    video2_entries[address] = {
        'x': x,
        'y': y,
        'zoom': zoom,
        'label': label
    }
    return label


def print_video_entries():
    for addr in sorted(cinematic_entries.keys()):
        v = cinematic_entries[addr]
        print (f"CINEMATIC: 0x{addr:04X} x:{v['x']} y:{v['y']} zoom:{v['zoom']}")
    for addr in sorted(video2_entries.keys()):
        v = video2_entries[addr]
        print (f"VIDEO2: 0x{addr:04X} x:{v['x']} y:{v['y']} zoom:{v['zoom']}")


SPECIAL_PURPOSE_VARS = {
    0x3c: "RANDOM_SEED",
    0x54: "HACK_VAR_54",
    0x67: "HACK_VAR_67",
    0xda: "LAST_KEYCHAR",
    0xdc: "HACK_VAR_DC",
    0xe5: "HERO_POS_UP_DOWN",
    0xf4: "MUS_MARK",
    0xf7: "HACK_VAR_F7",
    0xf9: "SCROLL_Y",
    0xfa: "HERO_ACTION",
    0xfb: "HERO_POS_JUMP_DOWN",
    0xfc: "HERO_POS_LEFT_RIGHT",
    0xfd: "HERO_POS_MASK",
    0xfe: "HERO_ACTION_POS_MASK",
    0xff: "PAUSE_SLICES"
}
def getVariableName(value):
    if value in SPECIAL_PURPOSE_VARS.keys():
        return SPECIAL_PURPOSE_VARS[value]
    else:
        return "0x%02X" % value


def get_label(addr):
    return "LABEL_%04X" % addr


class AWVM_Trace(ExecTrace):
    def output_disasm_headers(self):
        header = "; Generated by AnotherWorld_VMTools\n"
        for var in SPECIAL_PURPOSE_VARS.keys():
            name = SPECIAL_PURPOSE_VARS[var]
            header += "%s\t\tEQU 0x%02X\n" % (name, var)

        for addr in cinematic_entries.keys():
            v = cinematic_entries[addr]
            header += "%s\t\tEQU 0x%04X\n" % (v['label'], addr)

        for addr in video2_entries.keys():
            v = video2_entries[addr]
            header += "%s\t\tEQU 0x%04X\n" % (v['label'], addr)
        return header

    def disasm_instruction(self, opcode):
        if (opcode & 0x80) == 0x80:  # VIDEO
            offset = (((opcode & 0x7F) << 8) | self.fetch()) * 2
            x = self.fetch()
            y = self.fetch()
            #print("found video_entry {} at PC={}".format(hex(offset), hex(self.PC)))
            label = register_cinematic_entry(x, y, "0x40", offset)
            return "video type=%d, offset=%s, x=%d, y=%d" % (CINEMATIC, label, x, y)

        elif (opcode & 0x40) == 0x40: # VIDEO
            offset = self.fetch()
            offset = (((offset & 0x7F) << 8) | self.fetch()) * 2

            x_str = ""
            x = self.fetch()
            if not (opcode & 0x20):
                if not (opcode & 0x10):
                    x = (x << 8) | self.fetch()
                    x_str = "%d" % x
                else:
                    x_str = "[0x%02x]" % x
            else:
                if opcode & 0x10:
                    x += 0x100
                x_str = "%d" % x

            y_str = ""
            if not (opcode & 8):
                if not (opcode & 4):
                    y = self.fetch()
                    y = (y << 8) | self.fetch()
                    y_str = "%d" % y
                else:
                    y_str = "[0x%02x]" % self.fetch()
            else:
                y_str = "%d" % self.fetch()

            zoom_str = ""
            if not (opcode & 2):
                if not (opcode & 1):
                    zoom_str = "0x40"
                else:
                    zoom_str = "[0x%02x]" % self.fetch()
            else:
                if opcode & 1:
                    zoom_str = "0x40"
                else:
                    zoom_str = "[0x%02x]" % self.fetch()

            if opcode & 3 == 3:
                label = register_video2_entry(x_str, y_str, zoom_str, offset)
                return "video type=%d, offset=%s, x=%s, y=%s, zoom=%s" % (VIDEO2, label, x_str, y_str, zoom_str)
            else:
                label = register_cinematic_entry(x_str, y_str, zoom_str, offset)
                return "video type=%d, offset=%s, x=%s, y=%s, zoom=%s" % (CINEMATIC, label, x_str, y_str, zoom_str)

        elif opcode == 0x00: # movConst
            dstVar = getVariableName(self.fetch())
            immediate = self.fetch()
            immediate = (immediate << 8) | self.fetch()
            return "mov [%s], 0x%04X" % (dstVar, immediate)

        elif opcode == 0x01: # mov
            dstVar = getVariableName(self.fetch())
            srcVar = getVariableName(self.fetch())
            return "mov [%s], [%s]" % (dstVar, srcVar)

        elif opcode == 0x02: # add
            dstVar = getVariableName(self.fetch())
            srcVar = getVariableName(self.fetch())
            return "add [%s], [%s]" % (dstVar, srcVar)

        elif opcode == 0x03: # addConst
            dstVar = getVariableName(self.fetch())
            immediate = self.fetch()
            immediate = (immediate << 8) | self.fetch()
            if immediate >= 0x8000:
                return "sub [%s], 0x%04X" % (dstVar, 0x10000 - immediate)
            else:
                return "add [%s], 0x%04X" % (dstVar, immediate)

        elif opcode == 0x04: # call
            address = self.fetch()
            address = (address << 8) | self.fetch()
            self.subroutine(address)
            return "call %s" % get_label(address)

        elif opcode == 0x05: # ret
            self.return_from_subroutine()
            return "ret"

        elif opcode == 0x06: # break
            return "break"

        elif opcode == 0x07: # jmp
            address = self.fetch()
            address = (address << 8) | self.fetch()
            self.unconditional_jump(address)
            return "jmp %s" % get_label(address)

        elif opcode == 0x08: # setVec
            threadId = self.fetch();
            pcOffsetRequested = self.fetch()
            pcOffsetRequested = (pcOffsetRequested << 8) | self.fetch()
            self.schedule_entry_point(pcOffsetRequested)
            return "setup channel=0x%02X, address=%s" % (threadId, get_label(pcOffsetRequested))

        elif opcode == 0x09: # djnz = Decrement and Jump if Not Zero
            var = self.fetch();
            offset = self.fetch()
            offset = (offset << 8) | self.fetch()
            varName = getVariableName(var)
            self.conditional_branch(offset)
            return "djnz [%s], %s" % (varName, get_label(offset))

        elif opcode == 0x0a: # Conditional Jump instructions
            subopcode = self.fetch()
            b = self.fetch()
            c = self.fetch()
            var1Str = getVariableName(b)

            if subopcode & 0x80:
                var2Str = getVariableName(c)
                midterm = "[%s]" % var2Str
                offset = self.fetch()
                offset = (offset << 8) | self.fetch()
            elif subopcode & 0x40:
                midterm = "0x%04X" % ((c << 8) | self.fetch());
                offset = self.fetch()
                offset = (offset << 8) | self.fetch();
            else:
                midterm = "0x%02X" % c
                offset = self.fetch()
                offset = (offset << 8) | self.fetch();

            condition = subopcode & 7
            line = ""
            if condition == 0: # jz
                line = "je [%s]" % var1Str
            elif condition == 1: # jnz
                line = "jne [%s]" % var1Str
            elif condition == 2: # jg
                line = "jg [%s]" % var1Str
            elif condition == 3: # jge
                line = "jge [%s]" % var1Str
            elif condition == 4: # jl
                line = "jl [%s]" % var1Str
            elif condition == 5: # jle
                line = "jle [%s]" % var1Str
            else:
                return "; DISASM ERROR! Conditional JMP instruction with invalid condition (%d)" % condition

            self.conditional_branch(offset)
            line += ", %s, %s" % (midterm, get_label(offset))
            return line

        elif opcode == 0x0b: # setPalette
            paletteId = self.fetch()
            self.fetch() # waste a byte...
            return "setPalette 0x%02X" % paletteId

        elif opcode == 0x0c: # freezeChannel
            first = self.fetch()
            last = self.fetch()
            type = self.fetch()
            operation_names = [
              "freezeChannels",
              "unfreezeChannels",
              "deleteChannels"
            ]

            if type > 2:
                return "< invalid operation type for resetThread opcode >"
            else:
                return "%s first=0x%02X, last=0x%02X" % (operation_names[type], first, last)

        elif opcode == 0x0d: # selectVideoPage
            frameBufferId = self.fetch()
            return "selectVideoPage 0x%02X" % frameBufferId

        elif opcode == 0x0e: # fillVideoPage
            pageId = self.fetch()
            color = self.fetch()
            return "fill page=0x%02X, color=0x%02X" % (pageId, color)

        elif opcode == 0x0f: # copyVideoPage
            srcPageId = self.fetch()
            dstPageId = self.fetch()
            return "copyVideoPage src=0x%02X, dst=0x%02X" % (srcPageId, dstPageId)

        elif opcode == 0x10: # blitFrameBuffer
            pageId = self.fetch()
            return "blitFramebuffer 0x%02X" % pageId

        elif opcode == 0x11: # killChannel
            self.return_from_subroutine()
            return "killChannel"

        elif opcode == 0x12: # text
            stringId = self.fetch()
            stringId = (stringId << 8) | self.fetch()
            x = self.fetch()
            y = self.fetch()
            color = self.fetch()
            text_string = get_text_string(stringId)
            return "text id=0x%04X, x=%d, y=%d, color=0x%02X ; \"%s\"" % (stringId, x, y, color, text_string)

        elif opcode == 0x13: # sub
            var1Str = getVariableName(self.fetch())
            var2Str = getVariableName(self.fetch())
            return "sub [%s], [%s]" % (var1Str, var2Str)

        elif opcode == 0x14: # and
            dstVar = getVariableName(self.fetch())
            immediate = self.fetch()
            immediate = (immediate << 8) | self.fetch()
            return "and [%s], 0x%04X" % (dstVar, immediate)

        elif opcode == 0x15: # or
            dstVar = getVariableName(self.fetch())
            immediate = self.fetch()
            immediate = (immediate << 8) | self.fetch()
            return "or [%s], 0x%04X" % (dstVar, immediate)

        elif opcode == 0x16: # shift left
            variableId = self.fetch()
            leftShiftValue = self.fetch()
            leftShiftValue = (leftShiftValue << 8) | self.fetch()
            varStr = getVariableName(variableId)
            return "shl [%s], 0x%04X" % (varStr, leftShiftValue)

        elif opcode == 0x17: # shift right
            variableId = self.fetch()
            rightShiftValue = self.fetch()
            rightShiftValue = (rightShiftValue << 8) | self.fetch()
            varStr = getVariableName(variableId)
            return "shr [%s], 0x%04X" % (varStr, rightShiftValue)

        elif opcode == 0x18: # play
            resourceId = self.fetch()
            resourceId = (resourceId << 8) | self.fetch()
            freq = self.fetch()
            vol = self.fetch()
            channel = self.fetch()
            return "play id=0x%04X, freq=0x%02X, vol=0x%02X, channel=0x%02X" % (resourceId, freq, vol, channel)

        elif opcode == 0x19: # load
            immediate = self.fetch()
            immediate = (immediate << 8) | self.fetch()
            if immediate > 0x91:
                self.return_from_subroutine()
            return "load id=0x%04X" % immediate

        elif opcode == 0x1a: # song
            resNum = self.fetch()
            resNum = (resNum << 8) | self.fetch()
            delay = self.fetch()
            delay = (delay << 8) | self.fetch()
            pos = self.fetch()
            return "song id=0x%04X, delay=0x%04X, pos=0x%02X" % (resNum, delay, pos)

        else:
            self.illegal_instruction(opcode)
            return "; DISASM ERROR! Illegal instruction (opcode = 0x%02X)" % opcode

used_pdata = []
def visited_pdata(addr):
    """ Keeps track of all polygon data byte addresses that are
        read during extraction of the artwork data."""
    global used_pdata
    if addr not in used_pdata:
        used_pdata.append(addr)

def print_unused_polygon_data():
    """Prints which ranges of the polygon data have
       not been ever used in the bytecode."""
    max_addr = sorted(used_pdata)[-1]
    state = 0
    for addr in xrange(max_addr+1):
        if addr not in used_pdata:
            if state == 0:
                start = addr
                state = 1
            else:
                end = addr
        else:
            if state == 1:
                print (f"{hex(start)}-{hex(end)} ({(end-start+1)})")
                state = 0
    if state == 1:
        end = max_addr
        print (f"{hex(start)}-{hex(end)} ({(end-start+1)})")

game_level = None
polygon_data = None
pdata_offset = 0
def fetch_polygon_data():
    global pdata_offset
    try:
        value = polygon_data[game_level << 16 | pdata_offset]
    except:
        print ("ERROR: exception on fetch_polygon_data() FIXME!")
        return 0
    # visited_pdata(pdata_offset)
    pdata_offset += 1
    return value

DEFAULT_ZOOM = 0x40
MAX_POINTS = 50
def fillPolygon(c, zoom, color, cx, cy):
    #print("    <{}>".format(hex(pdata_offset)))
    bbox_w = fetch_polygon_data() * float(zoom) / DEFAULT_ZOOM;
    bbox_h = fetch_polygon_data() * float(zoom) / DEFAULT_ZOOM;
    numPoints = fetch_polygon_data()
    #print("        -> {} points polygon".format(numPoints))

    if not ((numPoints & 1) == 0 and numPoints < MAX_POINTS):
        print (f"error: numPoints = {numPoints}")
        return # FIXME! sys.exit(-1)

    #Read all points, directly from bytecode segment
    for i in range(numPoints):
        x = fetch_polygon_data() * float(zoom) / DEFAULT_ZOOM
        y = fetch_polygon_data() * float(zoom) / DEFAULT_ZOOM
        #print ("        {}   x:{} y:{}".format(hex(pdata_offset), x, y))
        if i==0:
            c.move_to(cx - bbox_w/2 + x, cy - bbox_h/2 + y)
        else:
            c.line_to(cx - bbox_w/2 + x, cy - bbox_h/2 + y)

    c.close_path()
    c.set_source_rgb(0, 0, 0) # TODO: add color fill
    c.stroke()

def readAndDrawPolygon(c, color, zoom, x, y):
    global pdata_offset

    value = fetch_polygon_data()

    if value >= 0xC0:
        if color & 0x80:
            color = value & 0x3F

        backup = pdata_offset
        fillPolygon(c, zoom, color, x, y)
        pdata_offset = backup
    else:
        value &= 0x3F
        if value == 2:
            readAndDrawPolygonHierarchy(c, zoom, x, y)
        else:
            print("ERROR: readAndDrawPolygon() (value != 2)\n")
            return # FIXME! sys.exit(-1)

def readAndDrawPolygonHierarchy(c, zoom, pgc_x, pgc_y):
    global pdata_offset
    pt_x = pgc_x - (fetch_polygon_data() * float(zoom) / DEFAULT_ZOOM)
    pt_y = pgc_y - (fetch_polygon_data() * float(zoom) / DEFAULT_ZOOM)
    num_children = fetch_polygon_data()

    #print ("  hierarchy with {} children.".format(num_children))
    for child in range(num_children):

        offset = fetch_polygon_data()
        offset = offset << 8 | fetch_polygon_data()

        po_x = pt_x + (fetch_polygon_data() * float(zoom) / DEFAULT_ZOOM)
        po_y = pt_y + (fetch_polygon_data() * float(zoom) / DEFAULT_ZOOM)
        #print "child #{}: offset={} ({}) po_x={} po_y={}".format(
        #  child,
        #  hex((2*offset) & 0xFFFF), hex(offset),
        #  po_x, po_y)

        color = 0xFF
        if offset & 0x8000:
            color = fetch_polygon_data() & 0x7F
            fetch_polygon_data() #and waste a byte...

        backup = pdata_offset

        pdata_offset = (offset & 0x7FFF) * 2
        readAndDrawPolygon(c, color, zoom, po_x, po_y);

        pdata_offset = backup

import os
from cairo import SVGSurface, Context, Matrix
COLOR_BLACK = 0xFF
def extract_polygon_data(romset_dir, cinematic):
    global polygon_data, pdata_offset
    global cinematic_entries
    global cinematic_counter
    global video2_entries
    global game_level

    if cinematic:
        try:
            polygon_data = open(f"{romset_dir}/cinematic.rom", "rb").read()
        except:
            print("FIXME! Did not find a cinematic.rom file...")
            return
        entries = cinematic_entries
        level_path = f"{output_dir}/level_{game_level}"
        dirpath = f"{level_path}/cinematic/"
        makedir(level_path)
    else:
        try:
            polygon_data = open(f"{romset_dir}/video2.rom", "rb").read()
        except:
            print("FIXME! Did not find a video2.rom file...")
            return

        entries = video2_entries
        dirpath = f"{output_dir}/common_video/"
        game_level = 0

    makedir(dirpath)

    for addr in entries.keys():
        entry = entries[addr]
        s = SVGSurface(f"{dirpath}/{entry['label']}.svg", 320, 200)
        c = Context(s)
        zoom = entry["zoom"]
        x = entry["x"]
        y = entry["y"]

        if not isinstance(zoom, int):
            zoom = 0x40 #HACK!

        if not isinstance(x, int):
            x = 160 #HACK!

        if not isinstance(y, int):
            y = 100 #HACK!

        #print ("\ndecoding polygons at {}: {}".format(hex(addr), entry))
        pdata_offset = addr
        readAndDrawPolygon(c, COLOR_BLACK, zoom, x, y)
        s.finish()

    # reset structures:
    cinematic_entries = {}
    cinematic_counter = 0

def makedir(path):
    if not os.path.exists(path):
        os.mkdir(path)

import sys
if len(sys.argv) != 3:
    print(f"usage: {sys.argv[0]} <romset_dir> <disasm_output_dir>")
else:
    romset_dir = sys.argv[1]
    output_dir = sys.argv[2]
    gamerom = f"{romset_dir}/bytecode.rom"
    makedir(output_dir)
    for game_level in range(9):
        print (f"disassembling level {game_level}...")
        trace = AWVM_Trace(gamerom, rombank=0x10000*game_level, loglevel=0)
        trace.run()
#    trace.print_ranges()
#    trace.print_grouped_ranges()
#    print_video_entries()

        level_path = f"{output_dir}/level_{game_level}"
        makedir(level_path)
        trace.save_disassembly_listing(f"{level_path}/level-{game_level}.asm")
        print (f"\t{len(cinematic_entries.keys())} cinematic entries.")
        # cinematic polygon data:
        used_pdata = []
        extract_polygon_data(romset_dir, True)
        # print_unused_polygon_data()


    # common polygon data:
    print (f"\t{len(video2_entries.keys())} video2 entries.")
    extract_polygon_data(romset_dir, False)


